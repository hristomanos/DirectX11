# 3D Triangle Grid #
 
A terrain can be generated by loading in a heightmap texture and applying the height values to the verticesâ€™ y component. A nested for loop iterates through the 2D array used for generating the 3D triangle grid terrain. For the x and z values, the size of a cell is multiplied with each iteration plus an offset at the end for separation. The Z component requires the multiplication to be negative in order for the indices to render the triangles looking up the Y vector so it can be viewed, otherwise the terrain is rendered upside down. Lastly, the texture coordinates are calculated by simply dividing each element with columns - 1 and rows - 1 respectively resulting to an accurately mapped texture as demonstrated bellow:
 
## Diamond-square

A procedural terrain generation algorithm was also implemented to generate a heightmap using the diamond square algorithm. Providing the algorithm with 4 random initial corner values of a 2D array will result in filling the inner values with midpoint displacement. It is worth noting that the algorithm requires with width and height of the 2D array to be 2n+1. For instance, the width and height that was used to test was 2x2 at minimum and 513x513 at maximum i.e. 20+1 and 28+1. This formula is important as the numbers it outputs possess an essential property for calculating their midpoints. The first step of the algorithm is called the diamond because it takes the average of the four corners subsequently giving back the value at the centre. Then, the next step is called the square as the midpoint of each of the edges is calculated by solving the average of its corner points. The function applies recursively the rest of the values to the rest of the points and adds a random displacement to each one for variety. 
A function was also added to smooth the spikes that were occurring throughout the terrain. The method used for smoothing out sudden spikes from some vertices is called average or mean filtering and the main purpose is to reduce intensity variation between vertices on the terrain. The way thus the function works is that it creates a copy of the generated heightmap and then checks all its 8 neighbouring vertices and store their height consequently taking the average of all and applying them back to the original heightmap.
   
